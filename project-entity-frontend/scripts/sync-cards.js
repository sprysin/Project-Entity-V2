import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const BACKEND_ROOT = path.resolve(__dirname, '../../src/ProjectEntity.Core/Cards');
const OUTPUT_FILE = path.resolve(__dirname, '../src/data/cards.ts');

// Ensure output directory exists (relative to script location)
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

// Data storage
const cards = [];

// Helper to walk directory
function walkDir(dir, callback) {
    if (!fs.existsSync(dir)) return;
    fs.readdirSync(dir).forEach(f => {
        let dirPath = path.join(dir, f);
        let isDirectory = fs.statSync(dirPath).isDirectory();
        isDirectory ? walkDir(dirPath, callback) : callback(path.join(dir, f));
    });
}

// Regex Patterns
const REGEX_PAWN_BASE = /: base\("([^"]+)", "([^"]+)"/;
const REGEX_CLASS_DEF = /public class (\w+) : (\w+)/;
const REGEX_LEVEL = /Level = (\d+);/;
const REGEX_ATTACK = /Attack = (\d+);/;
const REGEX_DEFENSE = /Defense = (\d+);/;
const REGEX_ATTRIBUTE = /Attribute = PawnAttribute\.(\w+);/;
const REGEX_PAWN_TYPE = /PawnType = PawnType\.(\w+);/;
const REGEX_EFFECT_TEXT = /EffectText = "([^"]+)";/;

// Action/Condition specific
const REGEX_ACTION_BASE = /: base\("([^"]+)", "([^"]+)", ActionSpeed\.(\w+)\)/;
const REGEX_CONDITION_BASE = /: base\("([^"]+)", "([^"]+)", ConditionType\.(\w+)\)/;

console.log(`Scanning for cards in: ${BACKEND_ROOT}`);

if (fs.existsSync(BACKEND_ROOT)) {
    walkDir(BACKEND_ROOT, (filePath) => {
        if (!filePath.endsWith('.cs')) return;

        const content = fs.readFileSync(filePath, 'utf8');
        const classMatch = content.match(REGEX_CLASS_DEF);

        if (!classMatch) return;

        const className = classMatch[1];
        const baseClass = classMatch[2];

        let card = null;

        if (baseClass === 'Pawn' || baseClass === 'SolsticeSentinel' || baseClass === 'HighKingOfTheWest') {
            const baseMatch = content.match(REGEX_PAWN_BASE);
            const id = baseMatch ? baseMatch[1] : className.toLowerCase().replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
            const name = baseMatch ? baseMatch[2] : className.replace(/([A-Z])/g, ' $1').trim();

            const levelMatch = content.match(REGEX_LEVEL);
            const atkMatch = content.match(REGEX_ATTACK);
            const defMatch = content.match(REGEX_DEFENSE);
            const attrMatch = content.match(REGEX_ATTRIBUTE);
            const typeMatch = content.match(REGEX_PAWN_TYPE);
            const effectMatch = content.match(REGEX_EFFECT_TEXT);

            card = {
                cardFamily: 'Pawn',
                id: id,
                name: name,
                level: levelMatch ? parseInt(levelMatch[1]) : 0,
                attribute: attrMatch ? attrMatch[1] : 'Normal',
                pawnType: typeMatch ? typeMatch[1] : 'Warrior',
                effectText: effectMatch ? effectMatch[1] : 'No effect text.',
                attack: atkMatch ? parseInt(atkMatch[1]) : 0,
                defense: defMatch ? parseInt(defMatch[1]) : 0,
            };

        } else if (baseClass === 'ActionCard') {
            const baseMatch = content.match(REGEX_ACTION_BASE);
            const id = baseMatch ? baseMatch[1] : className.toLowerCase();
            const name = baseMatch ? baseMatch[2] : className;
            const speed = baseMatch ? baseMatch[3] : 'Normal';
            const effectMatch = content.match(REGEX_EFFECT_TEXT);

            card = {
                cardFamily: 'Utility',
                id: id,
                name: name,
                type: 'Action',
                subType: speed,
                effectText: effectMatch ? effectMatch[1] : 'No effect text.',
            };

        } else if (baseClass === 'ConditionCard') {
            const baseMatch = content.match(REGEX_CONDITION_BASE);
            const id = baseMatch ? baseMatch[1] : className.toLowerCase();
            const name = baseMatch ? baseMatch[2] : className;
            const type = baseMatch ? baseMatch[3] : 'Normal';
            const effectMatch = content.match(REGEX_EFFECT_TEXT);

            card = {
                cardFamily: 'Utility',
                id: id,
                name: name,
                type: 'Condition',
                subType: type === 'Continuous' ? 'Lingering' : type,
                effectText: effectMatch ? effectMatch[1] : 'No effect text.',
            };
        }

        if (card) {
            console.log(`Found card: ${card.name} (${card.cardFamily})`);
            cards.push(card);
        }
    });

    const fileContent = `// This file is auto-generated by scripts/sync-cards.js
// Do not edit manually. run 'npm run sync-cards' to update.

import type { CardData } from '../types';

export const GAME_CARDS: CardData[] = ${JSON.stringify(cards, null, 4)};
`;

    fs.writeFileSync(OUTPUT_FILE, fileContent);
    console.log(`\nSuccessfully generated ${cards.length} cards to ${OUTPUT_FILE}`);

} else {
    console.error(`Backend directory not found: ${BACKEND_ROOT}`);
}
